import { Test } from '@nestjs/testing';
import { DestinationsService } from './destinations.service';
import { Destination } from './entities/destination.entity';
import { Repository } from 'typeorm';
import { getRepositoryToken } from '@nestjs/typeorm';
import { NotFoundException } from '@nestjs/common';
import { MockFunctionMetadata, ModuleMocker } from 'jest-mock';
import { Photo } from '../photos/entities/photo.entity';
import { IAService } from '../ai/interfaces/ai.service.interface';

// Disable console.error
global.console.error = jest.fn();

const moduleMocker = new ModuleMocker(global);

describe('DestinationsService', () => {
  let destinationsService: DestinationsService;
  let destinationRepository: Repository<Destination>;
  let iaService: IAService;

  const DESTINATION_REPOSITORY_TOKEN: string | Function = getRepositoryToken(Destination);

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [DestinationsService]
    })
    .useMocker((token) => {
      if (token === 'IAService') {
        return {
          generateText: jest.fn()
        }
      }
      if (token === 'DestinationRepository') {
        return {
          createQueryBuilder: jest.fn().mockReturnValue({
            leftJoinAndSelect: jest.fn().mockReturnThis(),
            where: jest.fn().mockReturnThis(),
            select: jest.fn().mockReturnThis(),
            getOne: jest.fn().mockResolvedValue(null)
          }),
          find: jest.fn().mockResolvedValue([]),
          findBy: jest.fn(),
          findOne: jest.fn(),
          save: jest.fn(),
          update: jest.fn().mockResolvedValue({ affected: 0, generatedMaps: [], raw: '' }),
          delete: jest.fn().mockResolvedValue({ affected: 0, raw: '' }),
        }
      }
      if (typeof token === 'function') {
        const moduleMetadata = moduleMocker.getMetadata(token) as MockFunctionMetadata<any, any>;
        const Mock = moduleMocker.generateFromMetadata(moduleMetadata);
        return new Mock();
      }
    })
    .compile();

    destinationRepository = moduleRef.get<Repository<Destination>>(DESTINATION_REPOSITORY_TOKEN);
    destinationsService = moduleRef.get<DestinationsService>(DestinationsService);
    iaService = moduleRef.get<IAService>('IAService');
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(destinationsService).toBeDefined();
  });

  it('destinationRepository should be defined', () => {
    expect(destinationRepository).toBeDefined();
  });
 
  describe('create', () => {
    const mockDestination = {
      name: 'Test Destination',
      photos: [
        { url: 'http://images/photo1.jpg', description: 'destination image' },
      ],
      target: 'A destination target',
    };

    it('should save destination with empty descriptive text when AI generation fails', async () => {
      (iaService.generateText as jest.Mock).mockImplementation(() => Promise.resolve(null));

      await destinationsService.create(mockDestination);

      expect(destinationRepository.save).toHaveBeenCalledWith({
        ...mockDestination,
        descriptiveText: ''
      });
    });

    it('should create a destination with AI auto-generating text if descriptive text is not provided', async () => {
      const expectedAIText = 'Text generated by AI';
      (iaService.generateText as jest.Mock).mockImplementation(() => Promise.resolve(expectedAIText));
      
      await destinationsService.create(mockDestination);

      expect(destinationRepository.save).toHaveBeenCalledWith({
        ...mockDestination,
        descriptiveText: expectedAIText,
      });
    });

    it('should call destinationRepository.save with correct params', async () => {
      const result = {
        ...mockDestination,
        descriptiveText: 'Descriptive text',
      };

      await destinationsService.create(result);

      expect(destinationRepository.save).toHaveBeenCalledWith(result);
      (iaService.generateText as jest.Mock).mockReset();
    });
  });

  describe('findAll', () => {
    it('should throw an error if destination not found', async () => {
      const result = destinationsService.findAll();

      expect(result).rejects.toBeInstanceOf(NotFoundException);
      expect(result).rejects.toThrow('Any destination was found');
    });
  });

  describe('findOne', () => {
    it('should throw an error if destination not found', async () => {
      const result = destinationsService.findOne('uuid');
      
      expect(result).rejects.toBeInstanceOf(NotFoundException);
      expect(result).rejects.toThrow('Destination not found');
    });
  });

  describe('update', () => {
    it('should throw an error if destination not found', async () => {
      const result = destinationsService.update('uuid', { name: 'Lisbon' });

      expect(result).rejects.toBeInstanceOf(NotFoundException);
      expect(result).rejects.toThrow('Destination not found');
    });
  });

  describe('remove', () => {
    it('should throw an error if destination not found', async () => {
      const result = destinationsService.remove('uuid');

      expect(result).rejects.toBeInstanceOf(NotFoundException);
      expect(result).rejects.toThrow('Destination not found');
    });
  });

  describe('attachPhotos', () => {
    it('should create a new photo and insert to a destination', async () => {
      const mockDestination = {
        id: '1',
        name: 'Test Destination',
        photos: [ new Photo ],
        target: 'A destination target',
        descriptiveText: 'description'
      };
      const files: Express.Multer.File[] = []

      jest.spyOn(destinationsService, 'findOne').mockResolvedValue(mockDestination);
  
      const result = await destinationsService.attachPhotos('1', files);

      expect(result).toHaveLength(1);
      expect(result[0]).toBeInstanceOf(Photo);
      expect(destinationRepository.save).toHaveBeenCalledWith(mockDestination);
    })
  });
});
